from numpy import *
import numpy as np
import pylab as p
from scipy import integrate
import matplotlib.pyplot as plt
from matplotlib.widgets import Slider

#-----------------------------------------------------------------------------#
# Choix des figures à afficher

f1 = False
f2 = True
f3 = False
f3a = False
f3b = False
f3c = False
f3d = False
f4 = False
f5 = False

#-----------------------------------------------------------------------------#

###########################- PARAMETRE À RÉGLER -##############################

#-----------------------------------------------------------------------------#

if f1 == True or f2 == True or f3 == True or f3a == True or f3b == True or f3c == True or f3d == True or f4 == True or f5 == True :
    
# Coef, temps pour graph population et graph de phase #

# Définition des coeficients
  a, b, c, d = 1.0, 0.1, 1.5, 0.75
  
# Définition du paramètre temps (discret)
  t = linspace(0, 15, 1000)
  t1 = linspace(0, 15, 200) # Pour plus petit temps de calcul sur graph 3D
  t2 = linspace(0, 70, 5000)
  T = linspace(0, 500, 5000)
#-----------------------------------------------------------------------------#

# Graph de variation des paramètres #
  X00 = [4, 2] # Condittions initiales
  t3a = linspace(0, 20, 500) # Temps pour alpha
  t3b = linspace(0, 20, 500) # Temps pour beta
  t3c = linspace(0, 20, 500) # Temps pour gamma
  t3d = linspace(0, 15, 500) # Temps pour delta
  
  # Valeurs dans lesquelles on fait varier les paramètres
  alphas = np.arange(0.4, 1.4, 0.1)
  betas = np.arange(0.4, 1.4, 0.1)
  gammas = np.arange(0.4, 1.4, 0.1)
  deltas = np.arange(0.4, 1.4, 0.1) 
  
#-----------------------------------------------------------------------------#
# Pour le graph de variations de dx/dt en fonction des conditions initales 

# Créer une suite 'values' compris 0 et 1 (pour ensuite faire * coord. point fixe)
  values  = linspace(0.3, 0.9, 10)

#-----------------------------------------------------------------------------#
# Pour les dégradés de couleurs

# Créer une liste 'vcolors' de la même taille que 'values' associant une 
# couleur à chaque valeur, sera utilisé dans la suite.
  vcolors = p.cm.winter_r(linspace(0.1, 1.0, len(values)))
  mcolors = p.cm.autumn_r(linspace(0.1, 1.0, len(values)))
  hcolors = p.cm.summer_r(linspace(0.1, 1.0, len(values)))
  rcolors = p.cm.rainbow_r(linspace(0.1, 1.0, len(values)))

#-----------------------------------------------------------------------------#
# Pour les graph avec équations avec termes supplémentaires

  # Valeurs que l'on va attribuer aux conditions initiales pour termes supp
  valuess  = linspace(1, 10, 10)
#-----------------------------------------------------------------------------#
  # Définition de la fonction dX/dt
  def dX_dt(X, t, a, b, c, d):
     return array([ a*X[0] - b*X[0]*X[1] , -c*X[1] + d*b*X[0]*X[1] ])
#-----------------------------------------------------------------------------#

####################- GRAPH AVEC LES ÉQUATIONS DE BASE -#######################

#-----------------------------------------------------------------------------#
# Défini figure 'fig1' si f1 = True : Plan de phase en fonction paramètre (3D)
if f1 == True :
    
   fig1 = plt.figure()
   # Définit les 3 axes de projection
   ax = plt.axes(projection='3d')
   
   # Pour 'v' et 'col' compris dans 'values'
   for v, col in zip(values, mcolors): 
      X0 = array([ v*c/(d*b) , v*a/b ]) # Conditions initales (proportionnel à v)
      X = integrate.odeint( dX_dt, X0, t1, args=(a,b,c,d)) # Intégration via odeint 
      ax.plot3D( X[:,0], X[:,1], t1, lw=1, color=col, label='$X_0$=(%.f,%.f)' % (X0[0],X0[1]) )
      ax.scatter(X0[0],X0[1], 0, s=70, marker='o',color=col) # Plot des conditions initiales
    
   # lw = épaisseur des courbes (proportionnel à v)
   # color = couleur des courbes (proportionnel à col, et donc à v)
   ax.set_xlabel('Proies',fontsize=16)
   ax.set_ylabel('Prédateurs',fontsize=16)
   ax.set_zlabel('Temps',fontsize=16)
   
   # Première méthode pour ajuster fenêtre d'affichage
   mngr = plt.get_current_fig_manager()
   mngr.window.setGeometry(0,70,750,750)
   
   # (Distance de gauche, distance d'en haut, largeur, hauteur)
   # Deuxième méthode pour ajuster fenêtre
   # fig1.set_size_inches(10, 10)
   plt.title('Figure')
   plt.legend()
#-----------------------------------------------------------------------------#
# Défini figure 'fig2' si f2 = True : Plan de phase
if f2 == True :
        
   fig2 = plt.figure()
   # les coord. du point fixe centrale
   valuesss  = linspace(3, 12, 10)
   def trace2(A,B,C,D) :
       
       def dX_dt(X, t, A, B, C, D):
             return array([ A*X[0] - B*X[0]*X[1] , -C*X[1] + D*B*X[0]*X[1] ])
       
       plt.scatter(C/(D*B), A/B, s=70, marker='o',color='r',label='(x,y)=(%.1f,%.1f)' % (C/(D*B), A/B)) # Plot du point fixe centrale
       
       for v, col in zip(valuesss, vcolors): 
           X0 = array([v,v])
           X = integrate.odeint( dX_dt, X0, T, args=(A,B,C,D))
           plt.plot(X[:,0], X[:,1], color=col, label='$X_0$=(%.f,%.f)' % (X0[0],X0[1]))
           plt.scatter(X0[0], X0[1], s=70, marker='o',color=col) # Plot des conditions initiales

           plt.legend()
       #-------------------------------------------------------------------------#
       # Vecteurs sur 'fig2' plan de phase
      
       ymax = p.ylim(ymin=0)[1] # On définit une valeur y max
       xmax = p.xlim(xmin=0)[1] # On définit une valeur x max
       nb_points   = 30         # Le nombre de point que l'on veut entre 0 et les max
      
       x = linspace(0, xmax, nb_points) # Liste de points entre 0 et xmax
       y = linspace(0, ymax, nb_points) # Liste de points entre 0 et ymax
      
       X1 , Y1  = meshgrid(x, y)  # Création d'une grille
       DX1, DY1 = dX_dt([X1, Y1],t,A,B,C,D) # On associe à chaque valeur la rapidité de convergence
       M = (hypot(DX1, DY1))      # Norme de la rapidité de convergence
       M [M == 0] = 1.0           # On retirer l'erreur de la division par 0
       DX1 = DX1/M                # Normalisation des vecteurs
       DY1 = DY1/M   
      
       # On utilise la fonction p.quiver pour tracer les vecteurs
       vecteur = p.quiver(X1, Y1, DX1, DY1, M, pivot='tail', cmap=p.cm.rainbow, angles='xy')

      #--------------------------------------------------------------------------#
      # Barre de glissement du point fixe centrale
                    
   axe_a = plt.axes([0.03, 0.1, 0.015, 0.8])
   axe_b = plt.axes([0.06, 0.1, 0.015, 0.8])
   axe_c = plt.axes([0.09, 0.1, 0.015, 0.8])
   axe_d = plt.axes([0.12, 0.1, 0.015, 0.8])

   fig2 = plt.axes([0.2, 0.1, 0.7, 0.8])

   barre_a = Slider(axe_a, label='a', valmin=0.1, valmax=2, valinit=a, orientation='vertical')
   barre_b = Slider(axe_b, label='b',valmin=0.1, valmax=2, valinit=b, orientation='vertical' )
   barre_c = Slider(axe_c, label='c', valmin=0.1, valmax=2, valinit=c, orientation='vertical')
   barre_d = Slider(axe_d, label='d',valmin=0.1, valmax=2, valinit=d, orientation='vertical' )
      
   def update(val):
       
       plt.cla() 
       plt.legend(loc='upper left')
       plt.xlabel('Proies',fontsize=15)
       plt.ylabel('Prédateurs',fontsize=15)
          
       A = barre_a.val
       B = barre_b.val
       C = barre_c.val
       D = barre_d.val

       trace2(A,B,C,D)

   barre_a.on_changed(update)
   barre_b.on_changed(update)
   barre_c.on_changed(update)
   barre_d.on_changed(update)

   mngr = plt.get_current_fig_manager()
   mngr.window.setGeometry(0,70,1000,750)

   update(0)
   #--------------------------------------------------------------------------#
   
#-----------------------------------------------------------------------------#
# Défini figure 'fig3' si f3 = True : Population en fonction du temps
if f3 == True :
    
   fig3 = plt.figure()
   
   for v, col in zip(values, vcolors): 
      X0 = array([ v*c/d , v*a/b ])
      X = integrate.odeint( dX_dt, X0, t, args=(a,b,c,d))
      plt.plot(t, X[:,0], lw=1, color=col, label='$X_0$=(%.f,%.f)' % (X0[0],X0[1]))
      plt.scatter(0, X0[0], s=40, marker='o',color=col) # Plot des conditions initiales
      plt.legend()
      
   for v, col in zip(values, mcolors): 
      X0 = array([ v*c/d , v*a/b ])
      X = integrate.odeint( dX_dt, X0, t, args=(a,b,c,d))
      plt.plot(t, X[:,1], lw=1, color=col, label='$X_0$=(%.f,%.f)' % (X0[0],X0[1]))
      plt.scatter(0, X0[1], s=40, marker='o',color=col)
      plt.legend()
      
   plt.xlabel('Temps',fontsize=16)
   plt.ylabel('Populations',fontsize=16)
   
   # fig3.set_size_inches(17, 10) -> Deuxième méthode pour fenêtre.
   mngr = plt.get_current_fig_manager()
   mngr.window.setGeometry(0,70,1438,750)
#-----------------------------------------------------------------------------#
# Défini figure 'fig3a' si f3a = True : dX_dt en fonction de a
if f3a == True :

   fig3a, ax3a = plt.subplots(2,1)
   fig3a.suptitle("Proies et prédateurs en fonction de alpha", size = 17 )
   
   def tracea(X,a,b,c,d) :
       
    for A, col in zip(alphas, vcolors):
       
       X = integrate.odeint(dX_dt, X00, t3a, args = (A,b,c,d))
       
       # ici, R signifie raw string, permet de créer une chaine brute
       # "%.1f" %b -> Remplace % par la valeur de b avec (.1f) 1 décimale
       ax3a[0].plot(t3a, X[:,0], color = col, label= R" $\alpha = $" + "%.1f" %A)
       ax3a[0].legend(loc='upper left', labelspacing=0.34)
       
    for A, col in zip(alphas, mcolors):
       
       X = integrate.odeint(dX_dt, X00, t3a, args = (A,b,c,d))
       
       ax3a[1].plot(t3a, X[:,1], color = col, label = R" $\alpha = $" + "%.1f" %A)
       ax3a[1].legend(loc='upper left', labelspacing=0.34)
       
   #--------------------------------------------------------------------------#
   # Barre de glissement des conditions initiales

   fig3a.subplots_adjust(right=0.91)
                         
   axe_x0a = plt.axes([0.03, 0.1, 0.015, 0.8])
   axe_y0a = plt.axes([0.06, 0.1, 0.015, 0.8])

   barre_x0a = Slider(axe_x0a, '$x_0$', valmin=0, valmax=10, valinit=4, 
                      orientation='vertical')
   barre_y0a = Slider(axe_y0a, label='$y_0$',valmin=0, valmax=10, valinit=2, 
                      orientation='vertical' )

   def update(val):
       
       ax3a[0].clear()
       ax3a[1].clear()
       ax3a[0].legend(loc='upper left', labelspacing=0.34)
       ax3a[1].legend(loc='upper left', labelspacing=0.34)
       ax3a[0].set_xlabel('Temps')
       ax3a[0].set_ylabel('Proies')
       ax3a[1].set_xlabel('Temps')
       ax3a[1].set_ylabel('Prédateurs');
       
       X00[0]=barre_x0a.val
       X00[1]=barre_y0a.val
       tracea(X00,a,b,c,d)
       
   barre_x0a.on_changed(update)
   barre_y0a.on_changed(update)

   update(0)
   #--------------------------------------------------------------------------#
   
   mngr = plt.get_current_fig_manager()
   mngr.window.setGeometry(0,70,1438,750)
#-----------------------------------------------------------------------------#
# Défini figure 'fig3b' si f3b = True : dX_dt en fonction de b
if f3b == True :
   
   fig3b, ax3b = plt.subplots(2,1)
   fig3b.suptitle("Proies et prédateurs en fonction de beta", size = 17 )
   
   def traceb(X,a,b,c,d) :
       
    for B, col in zip(betas, vcolors):
       
       X = integrate.odeint(dX_dt, X00, t3b, args = (a,B,c,d))
       
       # ici, R signifie raw string, permet de créer une chaine brute
       # "%.1f" %b -> Remplace % par la valeur de b avec (.1f) 1 décimale
       ax3b[0].plot(t3b, X[:,0], color = col, label= R" $\beta = $" + "%.1f" %B)
       ax3b[0].legend(loc='upper left', labelspacing=0.34)
        
    for B, col in zip(betas, mcolors):
        
       X = integrate.odeint(dX_dt, X00, t3b, args = (a,B,c,d))
       
       ax3b[1].plot(t3b, X[:,1], color = col, label = R" $\beta = $" + "%.1f" %B)
       ax3b[1].legend(loc='upper left',labelspacing=0.34)
       fig3b.suptitle("Proies et prédateurs en fonction de beta")
       
   #--------------------------------------------------------------------------#
   # Barre de glissement des conditins initiales

   fig3b.subplots_adjust(right=0.91)
                         
   axe_x0b = plt.axes([0.03, 0.1, 0.015, 0.8])
   axe_y0b = plt.axes([0.06, 0.1, 0.015, 0.8])

   barre_x0b= Slider(axe_x0b, '$x_0$', valmin=0, valmax=10, valinit=4, orientation='vertical')
   barre_y0b= Slider(axe_y0b, label='$y_0$',valmin=0, valmax=10, valinit=2, orientation='vertical' )

   def update(val):
       
       ax3b[0].clear()
       ax3b[1].clear()
       ax3b[0].legend(loc='upper left', labelspacing=0.34)
       ax3b[1].legend(loc='upper left', labelspacing=0.34)
       ax3b[0].set_xlabel('Temps')
       ax3b[0].set_ylabel('Proies')
       ax3b[1].set_xlabel('Temps')
       ax3b[1].set_ylabel('Prédateurs');
       
       X00[0]=barre_x0b.val
       X00[1]=barre_y0b.val
       traceb(X00,a,b,c,d)
       
   barre_x0b.on_changed(update)
   barre_y0b.on_changed(update)

   update(0)
   #--------------------------------------------------------------------------#

   mngr = plt.get_current_fig_manager()
   mngr.window.setGeometry(0,70,1438,750)
#-----------------------------------------------------------------------------#
# Défini figure 'fig3c' si f3c = True : dX_dt en fonction de c
if f3c == True :
    
   fig3c, ax3c = plt.subplots(2,1)
   fig3c.suptitle("Proies et prédateurs en fonction de gamma", size = 17 )
      
   def tracec(X,a,b,c,d) :
       
    for C, col in zip(gammas, vcolors):
       
       X = integrate.odeint(dX_dt, X00, t3c, args = (a,b,C,d))
       
       # ici, R signifie raw string, permet de créer une chaine brute
       # "%.1f" %b -> Remplace % par la valeur de b avec (.1f) 1 décimale
       ax3c[0].plot(t3c, X[:,0], color = col, label= R" $\gamma = $" + "%.1f" %C)
       ax3c[0].legend(loc='upper left', labelspacing=0.34)
       
    for C, col in zip(gammas, mcolors):
       
       X = integrate.odeint(dX_dt, X00, t3c, args = (a,b,C,d))
       
       ax3c[1].plot(t3c, X[:,1], color = col, label = R" $\gamma = $" + "%.1f" %C)
       ax3c[1].legend(loc='upper left', labelspacing=0.34)
       
       fig3c.suptitle("Proies et prédateurs en fonction de gamma")
       
   #--------------------------------------------------------------------------#
   # Barre de glissement des conditins initiales

   fig3c.subplots_adjust(right=0.91)
                         
   axe_x0c = plt.axes([0.03, 0.1, 0.015, 0.8])
   axe_y0c = plt.axes([0.06, 0.1, 0.015, 0.8])

   barre_x0c= Slider(axe_x0c, label='$x_0$', valmin=0, valmax=10, valinit=4, orientation='vertical')
   barre_y0c= Slider(axe_y0c, label='$y_0$',valmin=0, valmax=10, valinit=2, orientation='vertical' )

   def update(val):
       
       ax3c[0].clear()
       ax3c[1].clear()
       ax3c[0].legend(loc='upper left', labelspacing=0.34)
       ax3c[1].legend(loc='upper left', labelspacing=0.34)
       ax3c[0].set_xlabel('Temps')
       ax3c[0].set_ylabel('Proies')
       ax3c[1].set_xlabel('Temps')
       ax3c[1].set_ylabel('Prédateurs');
       
       X00[0]=barre_x0c.val
       X00[1]=barre_y0c.val
       tracec(X00,a,b,c,d)
       
   barre_x0c.on_changed(update)
   barre_y0c.on_changed(update)

   update(0)
   #--------------------------------------------------------------------------#
   
   mngr = plt.get_current_fig_manager()
   mngr.window.setGeometry(0,70,1438,750)
#-----------------------------------------------------------------------------#
# Défini figure 'fig3d' si f3d = True : dX_dt en fonction de d
if f3d == True :
   
   fig3d, ax3d = plt.subplots(2,1)
   fig3d.suptitle("Proies et prédateurs en fonction de delta", size = 16  )
   
   def traced(X,a,b,c,d) :
       
    for D, col in zip(deltas, vcolors):
       
       X = integrate.odeint(dX_dt, X00, t3d, args = (a,b,c,D))
       
       # ici, R signifie raw string, permet de créer une chaine brute
       # "%.1f" %b -> Remplace % par la valeur de b avec (.1f) 1 décimale
       ax3d[0].plot(t3d, X[:,0], color = col, label= R" $\delta = $" + "%.1f" %D)
       ax3d[0].legend(loc='upper left', labelspacing=0.34)
       
    for D, col in zip(deltas, mcolors):
       
       X = integrate.odeint(dX_dt, X00, t3d, args = (a,b,c,D))
       
       ax3d[1].plot(t3d, X[:,1], color = col, label = R" $\delta= $" + "%.1f" %D)
       ax3d[1].legend(loc='upper left', labelspacing=0.34)
       fig3d.suptitle("Proies et prédateurs en fonction de delta")
       
   #--------------------------------------------------------------------------#
   # Barre de glissement des conditins initiales

   fig3d.subplots_adjust(right=0.91)
                         
   axe_x0d = plt.axes([0.03, 0.1, 0.015, 0.8])
   axe_y0d = plt.axes([0.06, 0.1, 0.015, 0.8])

   barre_x0d= Slider(axe_x0d, label='$x_0$', valmin=0, valmax=10, valinit=4, orientation='vertical')
   barre_y0d= Slider(axe_y0d, label='$y_0$',valmin=0, valmax=10, valinit=2, orientation='vertical' )

   def update(val):
       
       ax3d[0].clear()
       ax3d[1].clear()
       ax3d[0].legend(loc='upper left', labelspacing=0.34)
       ax3d[1].legend(loc='upper left', labelspacing=0.34)
       ax3d[0].set_xlabel('Temps')
       ax3d[0].set_ylabel('Proies')
       ax3d[1].set_xlabel('Temps')
       ax3d[1].set_ylabel('Prédateurs');
       
       X00[0]=barre_x0d.val
       X00[1]=barre_y0d.val
       traced(X00,a,b,c,d)
       
   barre_x0d.on_changed(update)
   barre_y0d.on_changed(update)

   update(0)
   #--------------------------------------------------------------------------#
   
   mngr = plt.get_current_fig_manager()
   mngr.window.setGeometry(0,70,1438,750) 
#-----------------------------------------------------------------------------#

####################- AJOUT DES TERMES SUPPLÉMENTAIRES -########################

#-----------------------------------------------------------------------------#
def dXs_dt(X, t=0):

    e, f = 0.5, 0.8
    return array([ a*X[0] - b*X[0]*X[1]*X[2], 
                  -c*X[1]*X[2] + d*b*X[0]*X[1], 
                  -e*X[0]*X[2] + d*b*X[0]*X[1]])
#-----------------------------------------------------------------------------#
# Défini figure 'fig4' si f4 est True: Population en fonction du temps pour dXs/dt
if f4 == True :
    
   fig4 = plt.figure()
   
   for v, col in zip(valuess, vcolors): 
      X0 = array([v,v,v])
      X = integrate.odeint( dXs_dt, X0, t)
      plt.plot(t, X[:,0], lw=1, color=col, label='$X_0$=(%.f,%.f,%.f)' % (X0[0],X0[1],X0[2]))
      plt.scatter(0, X0[0], s=40, marker='o',color=col) # Plot des conditions initiales
 #     legend1 = fig4.legend('$X_0$=(%.f,%.f)' % (X0[0],X0[1]), title="Classes")
      
   for v, col in zip(valuess, mcolors): 
      X0 = array([v,v,v])
      X = integrate.odeint( dXs_dt, X0, t)
      plt.plot(t, X[:,1], lw=1, color=col, label='$X_0$=(%.f,%.f,%.f)' % (X0[0],X0[1],X0[2]) )
      plt.scatter(0, X0[1], s=40, marker='o',color=col) # Plot des conditions initiales
 #     legend2 = fig4.legend('$X_0$=(%.f,%.f)' % (X0[0],X0[1]), title="Classes")
      
   for v, col in zip(valuess, hcolors): 
      X0 = array([v,v,v])
      X = integrate.odeint( dXs_dt, X0, t)
      plt.plot(t, X[:,2], lw=1, color=col, label='$X_0$=(%.f,%.f,%.f)' % (X0[0],X0[1],X0[2]) )
      plt.scatter(0, X0[2], s=40, marker='o',color=col) # Plot des conditions initiales
      legend3 = fig4.legend('H+r"{0:.2f}".format(valuess)', title="Classes") 
   
   # Ligne limite (1 unité), ici si unité arbitraire popu. est en millier
   plt.plot([15,0], [0.001,0.001], '--k', lw=2)
   plt.xlabel('Temps (unité arbitraire)',fontsize=17)
   plt.ylabel('Population Proie / Prédateur (unité arbitraire) / 3ème acteur',fontsize=17)
   
   mngr = plt.get_current_fig_manager()
   mngr.window.setGeometry(0,70,1438,750)
#-----------------------------------------------------------------------------#
# Défini figure 'fig5' si f5 est True : Plan de phase (3D)
if f5 == True :
    
   fig5 = plt.figure()
   ax5 = plt.axes(projection='3d')
   
   # Pour 'v' et 'col' compris dans 'values'
   for v, col in zip(valuess, mcolors): 
      X0 = array([v,v,v]) # Conditions initales (proportionnel à v)
      X = integrate.odeint( dXs_dt, X0, t2) # Intégration via odeint 
      ax5.plot3D( X[:,0], X[:,1], X[:,2], lw=1, color=col, label='$X_0$=(%.f,%.f,%.f)' % (X0[0],X0[1],X0[2]) )
      ax5.scatter(X0[0], X0[1], X0[2], s=70, marker='o',color=col) # Plot des conditions initiales
      
   # lw = épaisseur des courbes (proportionnel à v)
   # color = couleur des courbes (proportionnel à col, et donc à v)
   ax5.set_xlabel('Proies',fontsize=16)
   ax5.set_ylabel('Prédateurs',fontsize=16)
   ax5.set_zlabel('3ème acteur',fontsize=16)
   
   # Première méthode pour ajuster fenêtre d'affichage
   mngr = plt.get_current_fig_manager()
   mngr.window.setGeometry(0,70,750,750)
   
   #(Distance de gauche, distance d'en haut, largeur, hauteur)
   # Deuxième méthode pour ajuster fenêtre
   #fig1.set_size_inches(10, 10)
   plt.legend()
#-----------------------------------------------------------------------------#

plt.show()
